import React, { useState } from 'react';
import { connect } from 'react-redux';
import { withStyles } from '@material-ui/core';

import {
  Grid,
  Table,
  TableEditColumn,
  TableEditRow,
  TableHeaderRow,
  TableTreeColumn
} from '@devexpress/dx-react-grid-material-ui';
import {
  CustomTreeData,
  EditingState,
  TreeDataState
} from '@devexpress/dx-react-grid';
import { setEditorData } from '../../../redux/actions/Data/dataActions';

const styles = theme => {
  return {
    dataGrid: {
      // gridArea: 'gridarea',
      // justifySelf: 'start'
    }
  };
};

const getRowId = row => (row.id || row.parentId) + '_' + row.internalId;

// const LookupEditCellBase = ({ value, onValueChange, classes, customDropDownItems }) => (
//   <TableCell
//     className={classes.lookupEditCell}
//   >
//     <Select
//       // ...
//     >
//       {customDropDownItems.map(item => (
//         <MenuItem key={item} value={item}>{item}</MenuItem>
//       ))}
//     </Select>
//   </TableCell>
// );

const ActionButton = props => {
  return <TableEditColumn.Command {...props} />;
};

const EditCell = props => {
  console.error(props);
  // const [text, setText] = useState(props.value ? '' + props.value : '');
  //
  // const copiedProps = {};
  // if (!props.editingEnabled) {
  //   copiedProps['value'] = '(Autogenerated)';
  // } else {
  //   return (
  //     <TableCell>
  //       <TextField
  //         value={text}
  //         onChange={e => {
  //           const value = e.target.value.toLowerCase().replace(/[\s-]/g, '_');
  //
  //           if (
  //             removeChars('abcdefghijklmnopqrstuvwxyz0123456789_', value) ===
  //               value &&
  //             value.length > 0
  //           ) {
  //             props.onValueChange(value);
  //             setText(value);
  //           } else if (value.length === 0) {
  //             setText(value);
  //             props.onValueChange('INVALID_ENUM_NAME');
  //           }
  //         }}
  //         margin="normal"
  //         fullWidth
  //       />
  //     </TableCell>
  //   );
  // }
  //
  // const newProps = Object.assign({}, props, copiedProps);

  return <TableEditRow.Cell {...props} />;
};

const CommandCell = props => (
  <TableEditColumn.Cell {...props}>
    {React.Children.toArray(props.children).map(child => {
      if (child.props.id === 'delete' && !props.tableRow.row.local) {
        const newProps = Object.assign({}, child.props, { disabled: true });
        return Object.assign({}, child, { props: newProps });
      } else {
        return child;
      }
    })}
  </TableEditColumn.Cell>
);

function removeChars(validChars, inputString) {
  var regex = new RegExp('[^' + validChars + ']', 'g');
  return inputString.replace(regex, '');
}

const getChildRows = (row, rootRows) => {
  return row ? row.childRows : rootRows;
};

// https://devexpress.github.io/devextreme-reactive/react/grid/docs/guides/data-formatting/

function NestedEditor(props) {
  // Declare a new state variable, which we'll call "count"
  const [columns] = useState([
    { name: 'id', title: 'ID' },
    { name: 'machineClass', title: 'MachineClass' },
    { name: 'inputItem', title: 'Input Item' },
    { name: 'inputQty', title: 'Input Quantity' },
    { name: 'outputItem', title: 'Output Item' },
    { name: 'outputQty', title: 'Output Quantity' }
  ]);

  const rows = props.data ? props.data.rows : [];
  console.error(props);

  const [tableColumnExtensions] = useState([{ columnName: 'id', width: 450 }]);

  const commitChanges = ({ added, changed, deleted }) => {
    let changedRows;

    if (added) {
      const startingAddedId = Math.max(...rows.map(item => item.id), -1) + 1;
      const addedRows = added.map((row, index) => {
        return {
          id: startingAddedId + index,
          ...row
        };
      });

      changedRows = [...rows, ...addedRows];
    }
    if (changed) {
      changedRows = rows.map(row =>
        changed[row.id] ? { ...row, ...changed[row.id] } : row
      );
    }
    if (deleted) {
      const deletedSet = new Set(deleted);
      changedRows = rows.filter(row => !deletedSet.has(row.id));
    }

    // const newDict = {
    //   rows: changedRows,
    //   reserved: props.data.reserved
    // };

    // props.setData({
    //   dataName: props.objectName,
    //   data: newDict
    // });
  };

  return (
    <div className={props.classes.dataGrid}>
      <Grid rows={rows} columns={columns} getRowId={getRowId}>
        <TreeDataState />
        <CustomTreeData getChildRows={getChildRows} />
        <EditingState
          onCommitChanges={commitChanges}
          columnExtensions={tableColumnExtensions}
        />
        <Table columnExtensions={tableColumnExtensions} />
        <TableHeaderRow />
        <TableTreeColumn for="id" />
        <TableEditRow cellComponent={EditCell} />
        <TableEditColumn
          showAddCommand
          showEditCommand
          showDeleteCommand
          cellComponent={CommandCell}
          commandComponent={ActionButton}
        />
        {/*<FilteringState defaultFilters={[]} />*/}
        {/*<IntegratedFiltering />*/}
        {/*<SortingState*/}
        {/*  defaultSorting={[{ columnName: 'id', direction: 'desc' }]}*/}
        {/*/>*/}

        {/*<IntegratedSorting />*/}
        {/*<Table />*/}
        {/*<TableHeaderRow showSortingControls />*/}
        {/*<TableFilterRow />*/}
      </Grid>
    </div>
  );
}

const mapStateToProps = (state, ownProps) => ({
  data: state.dataReducer[ownProps.objectName],
  data_original: state.dataReducer[ownProps.objectName + '_original']
});

const mapDispatchToProps = dispatch => ({
  setData: data => dispatch(setEditorData(data))
});

export default React.memo(
  connect(
    mapStateToProps,
    mapDispatchToProps
  )(withStyles(styles)(NestedEditor))
);
